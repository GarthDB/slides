<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrum Design Information Locations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 0;
            background: #f8f9fa;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin: 20px 0 10px 0;
            font-size: 24px;
            flex-shrink: 0;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            gap: 20px;
            padding: 0 20px;
            box-sizing: border-box;
        }
        
        #chart {
            background: white;
            flex: 2;
            min-width: 0;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .legend {
            flex: 1;
            max-width: 350px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 100vh;
        }
        
        .controls {
            border-bottom: 2px solid #E8F4FD;
            padding-bottom: 20px;
        }
        
        .controls h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }
        
        .highlight-modes {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .mode-option {
            padding: 8px 12px;
            border: 2px solid #E8F4FD;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .mode-option:hover {
            border-color: #0265DC;
            background: #E8F4FD;
        }
        
        .mode-option.active {
            border-color: #0265DC;
            background: #0265DC;
            color: white;
        }
        
        .mode-option .name {
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .mode-option .description {
            font-size: 12px;
            opacity: 0.8;
        }
        
        .legend-content {
            flex: 1;
            overflow-y: auto;
            min-height: 0; /* Allow flexbox child to shrink below its content size */
        }
        
        .legend h2 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 18px;
            font-weight: 600;
            border-bottom: 2px solid #E8F4FD;
            padding-bottom: 8px;
        }
        
        .legend ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .legend li {
            margin: 4px 0;
            padding: 4px 8px;
            border-radius: 4px;
            position: relative;
            font-size: 14px;
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .legend li:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .legend li.highlighted {
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border: 2px solid #0265DC;
        }
        
        .legend li::before {
            content: "â€¢";
            margin-right: 8px;
            font-weight: bold;
        }
        
        .legend ul ul {
            margin-left: 20px;
            margin-top: 4px;
        }
        
        .legend .depth-0 { color: #2c3e50; background: #E8F4FD; }
        .legend .depth-1 { color: #2c3e50; background: #B8E0FA; }
        .legend .depth-2 { color: #2c3e50; background: #7CC7F7; }
        .legend .depth-3 { color: white; background: #378EF0; }
        .legend .depth-4 { color: white; background: #0265DC; }
        .legend .depth-5 { color: white; background: #014BC4; }
        .legend .depth-6 { color: white; background: #0D3F9F; }
        .legend .depth-7 { color: white; background: #1B2F5F; }
        
        .node {
            cursor: pointer;
        }
        
        .node:hover {
            stroke: #000;
            stroke-width: 1.5px;
        }
        
        .node--leaf {
            fill: white;
        }
        
        .label {
            font: 10px sans-serif;
            text-anchor: middle;
            text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff;
            pointer-events: none;
        }
        
        .instructions {
            text-align: center;
            margin: 10px 0;
            color: #666;
            font-size: 14px;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Spectrum Design Information Locations</h1>
        <div class="main-content">
            <svg id="chart"></svg>
            <div class="legend">
                <div class="controls">
                    <h3>Highlight Mode</h3>
                    <div class="highlight-modes" id="highlight-modes"></div>
                </div>
                <div class="legend-content">
                    <h2>Structure</h2>
                    <div id="legend-content"></div>
                </div>
            </div>
        </div>
        <div class="instructions">
            Click on any circle to zoom in. Click on the background to zoom out.
        </div>
    </div>

    <script src="data.js"></script>
          <script>
        // Set up dimensions to fill the available space
        const container = document.querySelector('#chart');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Create color scale using Adobe Spectrum sequential cerulean palette
        const sequentialCerulean = [
            "#E8F4FD", // Lightest cerulean
            "#B8E0FA", // Light cerulean
            "#7CC7F7", // Medium-light cerulean
            "#378EF0", // Medium cerulean
            "#0265DC", // Primary cerulean
            "#014BC4", // Dark cerulean
            "#0D3F9F", // Darker cerulean
            "#1B2F5F"  // Darkest cerulean
        ];
        
        const color = d3.scaleOrdinal(sequentialCerulean)
            .domain([0, 1, 2, 3, 4, 5, 6, 7]);
            
        // Current highlight mode
        let currentMode = 'none';
        
        // Function to determine if a color is light (for contrast calculation)
        function isLightColor(color) {
            // Convert hex to RGB
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Calculate luminance using standard formula
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5;
        }

        // Build the hierarchy object
        const hierarchy = d3
            .hierarchy(data)
            .sum((d) => d.value);

        // Compute the 2d coordinates of nodes
        const packGenerator = d3.pack()
            .size([width, height])
            .padding(4); // space between circles
        const root = packGenerator(hierarchy);

        // Create SVG
        const svg = d3.select("#chart")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", `0 0 ${width} ${height}`);

        // Get all nodes
        const allNodes = root.descendants();

        // Create circles for all nodes
        const circles = svg
            .selectAll("circle")
            .data(allNodes)
            .join("circle")
            .attr("cx", (d) => d.x)
            .attr("cy", (d) => d.y)
            .attr("r", (d) => d.r)
            .attr("fill", (d) => getNodeColor(d))
            .attr("stroke", "white")
            .attr("stroke-width", 1)
            .style("cursor", "pointer")
            .attr("data-node-name", (d) => d.data.name)
            .on("mouseover", function(event, d) {
                highlightNode(d.data.name, true);
            })
            .on("mouseout", function(event, d) {
                highlightNode(d.data.name, false);
            });

        // Add smart positioned labels for nodes with sufficient size
        const labelGroups = svg
            .selectAll("g.label-group")
            .data(allNodes.filter(d => d.r > 15))
            .join("g")
            .attr("class", "label-group");

        labelGroups.each(function(d) {
            const group = d3.select(this);
            const fontSize = Math.min(Math.max(d.r / 4, 8), 12);
            const lineHeight = fontSize * 1.1;
            
            // Determine if this should be an external label based on whether it has children
            const isLeafNode = !d.children || d.children.length === 0;
            const shouldBeExternal = !isLeafNode; // Only parent nodes get external labels
            const maxWidth = shouldBeExternal ? 120 : d.r * 1.6; // Fixed width for external labels
            const isLight = d.depth <= 2;
            const textColor = isLight ? "#2c3e50" : "white";
            
            // Calculate label position
            let labelX = d.x;
            let labelY = d.y;
            let textAnchor = "middle";
            let isExternal = false;
            
            if (shouldBeExternal) {
                // Determine which side the circle is closest to
                const margin = 12;
                const distanceToLeft = d.x;
                const distanceToRight = width - d.x;
                const distanceToTop = d.y;
                const distanceToBottom = height - d.y;
                
                // Choose primary side based on proximity to edges
                const isCloserToLeft = distanceToLeft < distanceToRight;
                const isCloserToTop = distanceToTop < distanceToBottom;
                
                // Create positions array with smart ordering based on proximity
                let positions;
                if (isCloserToLeft) {
                    // Prefer left side for circles closer to left edge
                    positions = [
                        { x: d.x - d.r - margin, y: d.y, anchor: "end", score: 0 },     // Left (preferred)
                        { x: d.x + d.r + margin, y: d.y, anchor: "start", score: 1 },   // Right
                        { x: d.x, y: isCloserToTop ? d.y + d.r + margin + 15 : d.y - d.r - margin - 15, anchor: "middle", score: 2 }
                    ];
                } else {
                    // Prefer right side for circles closer to right edge
                    positions = [
                        { x: d.x + d.r + margin, y: d.y, anchor: "start", score: 0 },   // Right (preferred)
                        { x: d.x - d.r - margin, y: d.y, anchor: "end", score: 1 },     // Left
                        { x: d.x, y: isCloserToTop ? d.y + d.r + margin + 15 : d.y - d.r - margin - 15, anchor: "middle", score: 2 }
                    ];
                }
                
                // Filter positions that are within bounds
                const validPositions = positions.filter(pos => 
                    pos.x >= 80 && pos.x <= width - 80 && 
                    pos.y >= 30 && pos.y <= height - 30
                );
                
                // If we have valid positions, use the best one
                if (validPositions.length > 0) {
                    const bestPos = validPositions[0]; // First is best due to smart ordering
                    labelX = bestPos.x;
                    labelY = bestPos.y;
                    textAnchor = bestPos.anchor;
                    isExternal = true;
                } else {
                    // Fallback: use the preferred side even if it goes slightly outside bounds
                    if (isCloserToLeft) {
                        labelX = d.x - d.r - margin;
                        labelY = d.y;
                        textAnchor = "end";
                    } else {
                        labelX = d.x + d.r + margin;
                        labelY = d.y;
                        textAnchor = "start";
                    }
                    isExternal = true;
                }
            }
            
            group.attr("transform", `translate(${labelX}, ${labelY})`);
            
            // Split text into words and create lines that fit
            const words = d.data.name.split(/\s+/);
            const lines = [];
            let currentLine = "";
            
            // Simple word wrapping
            for (const word of words) {
                const testLine = currentLine ? currentLine + " " + word : word;
                const testWidth = testLine.length * fontSize * 0.6; // Approximate width
                
                if (testWidth <= maxWidth) {
                    currentLine = testLine;
                } else {
                    if (currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        // Single word too long, truncate it
                        const maxChars = Math.floor(maxWidth / (fontSize * 0.6));
                        lines.push(word.substring(0, maxChars - 3) + "...");
                        currentLine = "";
                    }
                }
            }
            if (currentLine) lines.push(currentLine);
            
            // Limit to 2 lines for external labels, 3 for internal
            const maxLines = isExternal ? 2 : 3;
            const displayLines = lines.slice(0, maxLines);
            if (lines.length > maxLines) {
                displayLines[maxLines - 1] = displayLines[maxLines - 1].substring(0, displayLines[maxLines - 1].length - 3) + "...";
            }
            
            // Calculate starting Y position to center the text block
            const totalHeight = displayLines.length * lineHeight;
            const startY = -(totalHeight / 2) + (lineHeight / 2);
            
            // Add text lines
            displayLines.forEach((line, i) => {
                group.append("text")
                    .attr("x", 0)
                    .attr("y", startY + (i * lineHeight))
                    .attr("text-anchor", textAnchor)
                    .attr("dominant-baseline", "middle")
                    .style("font-size", fontSize + "px")
                    .style("font-family", "system-ui, -apple-system, 'Segoe UI', sans-serif")
                    .style("font-weight", isExternal ? "600" : "500") // Bold for external labels
                    .style("fill", isExternal ? "#2c3e50" : (isLeafNode ? (isLightColor(getNodeColor(d)) ? "#2c3e50" : "white") : textColor)) // External labels dark, leaf nodes adaptive, others based on depth
                    .style("pointer-events", "none")
                    .text(line);
            });
            
            // Add connecting line for external labels
            if (isExternal) {
                group.append("line")
                    .attr("x1", d.x - labelX)
                    .attr("y1", d.y - labelY)
                    .attr("x2", textAnchor === "start" ? -8 : textAnchor === "end" ? 8 : 0)
                    .attr("y2", 0)
                    .attr("stroke", "#0265DC")
                    .attr("stroke-width", 1.5)
                    .attr("opacity", 0.7);
            }
        });

        // Get node color based on current highlight mode
        function getNodeColor(d) {
            if (currentMode === 'none') {
                return color(d.depth);
            }
            
            const nodeData = d.data;
            
            switch (currentMode) {
                case 'llm':
                    return nodeData.categories && nodeData.categories.includes('llm') ? highlightModes.llm.color : '#f0f0f0';
                case 'mcp':
                    return nodeData.categories && nodeData.categories.includes('mcp') ? highlightModes.mcp.color : '#f0f0f0';
                case 'both':
                    return nodeData.categories && nodeData.categories.includes('llm') && nodeData.categories.includes('mcp') ? highlightModes.both.color : '#f0f0f0';
                case 'category':
                    // Use the first (primary) category for coloring
                    const primaryCategory = nodeData.categories ? nodeData.categories[0] : null;
                    return highlightModes.category.colors[primaryCategory] || '#f0f0f0';
                default:
                    return color(d.depth);
            }
        }
        
        // Update visualization based on highlight mode
        function updateHighlightMode(mode) {
            currentMode = mode;
            
            // Update circle colors
            circles.transition()
                .duration(500)
                .attr("fill", (d) => getNodeColor(d));
                
            // Update label colors based on new background colors
            labelGroups.selectAll("text").transition()
                .duration(500)
                .style("fill", function() {
                    const labelGroup = d3.select(this.parentNode);
                    const d = labelGroup.datum();
                    const isLeafNode = !d.children || d.children.length === 0;
                    const isExternal = !isLeafNode;
                    const isLight = d.depth <= 2;
                    const textColor = isLight ? "#2c3e50" : "white";
                    
                    if (isExternal) {
                        return "#2c3e50"; // External labels always dark
                    } else if (isLeafNode) {
                        return isLightColor(getNodeColor(d)) ? "#2c3e50" : "white"; // Adaptive for leaf nodes
                    } else {
                        return textColor; // Depth-based for parent nodes
                    }
                });
                
            // Update active mode in controls
            document.querySelectorAll('.mode-option').forEach(option => {
                option.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
        }

        // Highlight function for bidirectional interaction
        function highlightNode(nodeName, isHighlighted) {
            // Highlight circle in chart
            const circle = d3.select(`circle[data-node-name="${nodeName}"]`);
            if (!circle.empty()) {
                if (isHighlighted) {
                    circle.attr("stroke", "#000").attr("stroke-width", 3);
                } else {
                    circle.attr("stroke", "white").attr("stroke-width", 1);
                }
            }
            
            // Highlight item in legend
            const legendItem = document.querySelector(`li[data-node-name="${nodeName}"]`);
            if (legendItem) {
                if (isHighlighted) {
                    legendItem.classList.add('highlighted');
                } else {
                    legendItem.classList.remove('highlighted');
                }
            }
        }

        // Generate the legend/structure list
        function createLegend(data, depth = 0) {
            const ul = document.createElement('ul');
            
            if (data.children) {
                data.children.forEach(child => {
                    const li = document.createElement('li');
                    li.textContent = child.name;
                    li.className = `depth-${depth}`;
                    li.setAttribute('data-node-name', child.name);
                    
                    // Add hover events to legend items
                    li.addEventListener('mouseenter', () => {
                        highlightNode(child.name, true);
                    });
                    
                    li.addEventListener('mouseleave', () => {
                        highlightNode(child.name, false);
                    });
                    
                    if (child.children) {
                        li.appendChild(createLegend(child, depth + 1));
                    }
                    
                    ul.appendChild(li);
                });
            }
            
            return ul;
        }

        // Create highlight mode controls
        function createHighlightControls() {
            const highlightModesContainer = document.getElementById('highlight-modes');
            
            Object.entries(highlightModes).forEach(([modeKey, modeConfig]) => {
                const modeOption = document.createElement('div');
                modeOption.className = 'mode-option';
                if (modeKey === 'none') modeOption.classList.add('active');
                modeOption.setAttribute('data-mode', modeKey);
                
                const name = document.createElement('div');
                name.className = 'name';
                name.textContent = modeConfig.name;
                
                const description = document.createElement('div');
                description.className = 'description';
                description.textContent = modeConfig.description;
                
                modeOption.appendChild(name);
                modeOption.appendChild(description);
                
                modeOption.addEventListener('click', () => {
                    updateHighlightMode(modeKey);
                });
                
                highlightModesContainer.appendChild(modeOption);
            });
        }

        // Add the legend to the page
        const legendContent = document.getElementById('legend-content');
        const legendList = createLegend(data);
        legendContent.appendChild(legendList);
        
        // Create the highlight controls
        createHighlightControls();
    </script>
</body>
</html>

